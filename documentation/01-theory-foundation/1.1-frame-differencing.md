# Frame Differencing (So Sánh Khung Hình) - Phát Hiện Chuyển Động

## 1. Định Nghĩa

**Frame Differencing** (So sánh khung hình) là kỹ thuật phát hiện chuyển động bằng cách so sánh sự khác biệt giữa các khung hình liên tiếp trong video.

---

## 2. Nguyên Lý Hoạt Động

### Thuật Toán Cơ Bản

```
D(t) = |F(t) - F(t-1)|
```

Trong đó:
- **F(t)**: Khung hình hiện tại
- **F(t-1)**: Khung hình trước đó
- **D(t)**: Ảnh sự khác biệt (difference image)

### Các Bước Thực Hiện

1. Đọc khung hình F(t)
2. Chuyển sang grayscale (ảnh xám)
3. Tính difference (sự khác biệt) với khung hình trước
4. Áp dụng threshold (ngưỡng hóa)
5. Morphological operations (phép toán hình thái) - tùy chọn
6. Tìm contours (đường viền)
7. Vẽ bounding boxes (hộp giới hạn)

---

## 3. Các Biến Thể

### A. Two-Frame Difference (So sánh hai khung hình)

```python
diff = cv2.absdiff(frame_t, frame_t_1)
```

**Ưu điểm:** Đơn giản, nhanh
**Nhược điểm:** Nhạy với nhiễu

### B. Three-Frame Difference (So sánh ba khung hình)

```python
diff1 = cv2.absdiff(frame_t, frame_t_1)
diff2 = cv2.absdiff(frame_t_1, frame_t_2)
motion = cv2.bitwise_and(diff1, diff2)
```

**Ưu điểm:** Mạnh mẽ hơn (robust)
**Nhược điểm:** Chậm hơn, có thể bỏ sót chuyển động nhanh

### C. Weighted Difference (So sánh có trọng số)

```python
diff = cv2.absdiff(frame_t, alpha*frame_t_1 + (1-alpha)*frame_t_2)
```

**Ưu điểm:** Làm mượt theo thời gian (temporal smoothing)
**Nhược điểm:** Phức tạp hơn

---

## 4. Lựa Chọn Ngưỡng (Threshold Selection)

### Fixed Threshold (Ngưỡng cố định)

```python
threshold = 25
_, binary = cv2.threshold(diff, threshold, 255, cv2.THRESH_BINARY)
```

### Adaptive Threshold (Ngưỡng thích ứng)

```python
binary = cv2.adaptiveThreshold(diff, 255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY, 11, 2)
```

### Otsu's Method (Phương pháp Otsu)

```python
_, binary = cv2.threshold(diff, 0, 255,
    cv2.THRESH_BINARY + cv2.THRESH_OTSU)
```

---

## 5. Morphological Post-Processing (Xử Lý Hình Thái Hậu Kỳ)

```python
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))

# Loại bỏ nhiễu (opening)
opened = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)

# Lấp lỗ hổng (closing)
closed = cv2.morphologyEx(opened, cv2.MORPH_CLOSE, kernel)

# Làm mượt ranh giới (boundaries)
dilated = cv2.dilate(closed, kernel, iterations=2)
```

---

## 6. Ưu & Nhược Điểm

### Ưu Điểm
✅ Đơn giản, dễ triển khai (implement)
✅ Tính toán nhanh
✅ Không cần huấn luyện (training)
✅ Hoạt động tốt với camera tĩnh (static camera)

### Nhược Điểm
❌ Nhạy với nhiễu
❌ Bị ảnh hưởng bởi thay đổi ánh sáng
❌ Camera rung tạo phát hiện sai (false detections)
❌ Chỉ phát hiện vật thể di chuyển (moving objects), không phát hiện vật thể đứng yên
❌ Hiệu ứng bóng ma (ghost effect) - lỗ hổng trong vật thể di chuyển

---

## 7. Cải Thiện

### 1. Gaussian Blur (Làm mờ Gaussian)
```python
frame = cv2.GaussianBlur(frame, (5, 5), 0)
```
Giảm nhiễu trước khi tính sự khác biệt (difference)

### 2. Background Subtraction (Trừ nền)
Thay vì F(t-1), dùng mô hình nền đã học (learned background model)

### 3. Multi-Scale (Đa tỷ lệ)
Tính differences ở nhiều độ phân giải

### 4. Temporal Median (Trung vị theo thời gian)
Dùng median của N khung hình cuối thay vì 1 khung hình

---

## 8. Ứng Dụng

- Phát hiện chuyển động trong giám sát (surveillance)
- Nhận dạng hoạt động (activity recognition)
- Phát hiện thay đổi (change detection)
- Nén video (video compression) - ước lượng chuyển động (motion estimation)
- Phân tích thể thao (sports analysis)

---

## 9. So Sánh Với Background Subtraction (Trừ Nền)

| Đặc điểm | Frame Diff | Background Subtraction |
|---------|------------|------------------------|
| **Độ phức tạp** | Thấp | Trung bình - Cao |
| **Tốc độ** | Nhanh | Trung bình |
| **Độ chính xác** | Trung bình | Cao |
| **Xử lý ánh sáng** | Nhạy cảm | Thích ứng (adaptive) |
| **Thiết lập** | Không cần | Cần giai đoạn học (learning period) |
| **Vật thể đứng yên** | ❌ | ✅ |

---

## 10. Ví Dụ Triển Khai

```python
import cv2
import numpy as np

def frame_difference(video_path):
    cap = cv2.VideoCapture(video_path)
    ret, frame1 = cap.read()
    ret, frame2 = cap.read()

    while cap.isOpened():
        # Chuyển sang ảnh xám
        gray1 = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)
        gray2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)

        # Tính sự khác biệt
        diff = cv2.absdiff(gray1, gray2)

        # Áp dụng Gaussian blur để giảm nhiễu
        diff = cv2.GaussianBlur(diff, (5, 5), 0)

        # Ngưỡng hóa
        _, thresh = cv2.threshold(diff, 25, 255, cv2.THRESH_BINARY)

        # Phép toán hình thái
        kernel = np.ones((5, 5), np.uint8)
        thresh = cv2.dilate(thresh, kernel, iterations=2)

        # Tìm đường viền
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)

        # Vẽ hộp giới hạn
        for contour in contours:
            if cv2.contourArea(contour) > 1000:  # Lọc vùng nhỏ
                x, y, w, h = cv2.boundingRect(contour)
                cv2.rectangle(frame2, (x, y), (x+w, y+h), (0, 255, 0), 2)

        # Hiển thị
        cv2.imshow("Frame Difference", frame2)
        cv2.imshow("Threshold", thresh)

        # Cập nhật khung hình
        frame1 = frame2
        ret, frame2 = cap.read()

        if not ret or cv2.waitKey(30) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()
```

---

## 11. Tài Liệu Tham Khảo

- "Background and Foreground Modeling" (Piccardi, 2004)
- "Adaptive Background Mixture Models" (Stauffer & Grimson, 1999)
- OpenCV Documentation: Background Subtraction

---

**Ngày tạo**: Tháng 1/2025
**Phiên bản**: 1.0
