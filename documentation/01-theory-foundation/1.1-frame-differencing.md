# Frame Differencing - Phát Hiện Chuyển Động

## 1. Định Nghĩa

**Frame Differencing** là kỹ thuật phát hiện chuyển động bằng cách so sánh sự khác biệt giữa các frame liên tiếp trong video.

---

## 2. Nguyên Lý Hoạt Động

### Thuật Toán Cơ Bản

```
D(t) = |F(t) - F(t-1)|
```

Trong đó:
- **F(t)**: Frame hiện tại
- **F(t-1)**: Frame trước đó
- **D(t)**: Ảnh sự khác biệt (difference image)

### Các Bước Thực Hiện

1. Đọc frame F(t)
2. Chuyển sang grayscale
3. Tính difference với frame trước
4. Áp dụng threshold
5. Morphological operations (optional)
6. Tìm contours
7. Vẽ bounding boxes

---

## 3. Các Biến Thể

### A. Two-Frame Difference

```python
diff = cv2.absdiff(frame_t, frame_t_1)
```

**Ưu điểm:** Đơn giản, nhanh
**Nhược điểm:** Nhạy với nhiễu

### B. Three-Frame Difference

```python
diff1 = cv2.absdiff(frame_t, frame_t_1)
diff2 = cv2.absdiff(frame_t_1, frame_t_2)
motion = cv2.bitwise_and(diff1, diff2)
```

**Ưu điểm:** Robust hơn
**Nhược điểm:** Chậm hơn, có thể bỏ sót fast motion

### C. Weighted Difference

```python
diff = cv2.absdiff(frame_t, alpha*frame_t_1 + (1-alpha)*frame_t_2)
```

**Ưu điểm:** Temporal smoothing
**Nhược điểm:** Phức tạp hơn

---

## 4. Threshold Selection

### Fixed Threshold

```python
threshold = 25
_, binary = cv2.threshold(diff, threshold, 255, cv2.THRESH_BINARY)
```

### Adaptive Threshold

```python
binary = cv2.adaptiveThreshold(diff, 255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY, 11, 2)
```

### Otsu's Method

```python
_, binary = cv2.threshold(diff, 0, 255,
    cv2.THRESH_BINARY + cv2.THRESH_OTSU)
```

---

## 5. Morphological Post-Processing

```python
kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))

# Loại bỏ nhiễu (opening)
opened = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)

# Lấp lỗ hổng (closing)
closed = cv2.morphologyEx(opened, cv2.MORPH_CLOSE, kernel)

# Làm mượt boundaries
dilated = cv2.dilate(closed, kernel, iterations=2)
```

---

## 6. Ưu & Nhược Điểm

### Ưu Điểm
✅ Đơn giản, dễ implement
✅ Tính toán nhanh
✅ Không cần training
✅ Hoạt động tốt với static camera

### Nhược Điểm
❌ Nhạy với nhiễu
❌ Bị ảnh hưởng bởi thay đổi ánh sáng
❌ Camera rung tạo false detections
❌ Chỉ phát hiện moving objects (không phát hiện stationary)
❌ Ghost effect (lỗ hổng trong moving objects)

---

## 7. Cải Thiện

### 1. Gaussian Blur
```python
frame = cv2.GaussianBlur(frame, (5, 5), 0)
```
Giảm nhiễu trước khi tính difference

### 2. Background Subtraction
Thay vì F(t-1), dùng learned background model

### 3. Multi-Scale
Tính differences ở nhiều độ phân giải

### 4. Temporal Median
Dùng median của N frames cuối thay vì 1 frame

---

## 8. Ứng Dụng

- Phát hiện chuyển động trong surveillance
- Activity recognition
- Change detection
- Video compression (motion estimation)
- Sports analysis

---

## 9. So Sánh Với Background Subtraction

| Feature | Frame Diff | Background Subtraction |
|---------|------------|------------------------|
| **Độ phức tạp** | Thấp | Trung bình - Cao |
| **Tốc độ** | Nhanh | Trung bình |
| **Độ chính xác** | Trung bình | Cao |
| **Xử lý ánh sáng** | Nhạy cảm | Adaptive |
| **Setup** | Không cần | Cần learning period |
| **Stationary objects** | ❌ | ✅ |

---

## 10. Implementation Example

```python
import cv2
import numpy as np

def frame_difference(video_path):
    cap = cv2.VideoCapture(video_path)
    ret, frame1 = cap.read()
    ret, frame2 = cap.read()

    while cap.isOpened():
        # Chuyển sang grayscale
        gray1 = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)
        gray2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)

        # Tính difference
        diff = cv2.absdiff(gray1, gray2)

        # Áp dụng Gaussian blur
        diff = cv2.GaussianBlur(diff, (5, 5), 0)

        # Threshold
        _, thresh = cv2.threshold(diff, 25, 255, cv2.THRESH_BINARY)

        # Morphology
        kernel = np.ones((5, 5), np.uint8)
        thresh = cv2.dilate(thresh, kernel, iterations=2)

        # Tìm contours
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)

        # Vẽ bounding boxes
        for contour in contours:
            if cv2.contourArea(contour) > 1000:  # Lọc vùng nhỏ
                x, y, w, h = cv2.boundingRect(contour)
                cv2.rectangle(frame2, (x, y), (x+w, y+h), (0, 255, 0), 2)

        # Hiển thị
        cv2.imshow("Frame Difference", frame2)
        cv2.imshow("Threshold", thresh)

        # Cập nhật frames
        frame1 = frame2
        ret, frame2 = cap.read()

        if not ret or cv2.waitKey(30) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()
```

---

## 11. Tài Liệu Tham Khảo

- "Background and Foreground Modeling" (Piccardi, 2004)
- "Adaptive Background Mixture Models" (Stauffer & Grimson, 1999)
- OpenCV Documentation: Background Subtraction

---

**Ngày tạo**: Tháng 1/2025
**Phiên bản**: 1.0
