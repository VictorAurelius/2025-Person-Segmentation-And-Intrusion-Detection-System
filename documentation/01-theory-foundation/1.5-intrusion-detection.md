# Intrusion Detection - Phát Hiện Xâm Nhập

## 1. Tổng Quan

**Intrusion Detection** là kỹ thuật phát hiện khi đối tượng (người) xâm nhập vào khu vực cấm (ROI - Region of Interest).

---

## 2. Khái Niệm ROI (Region of Interest)

### Định Nghĩa

ROI là vùng được định nghĩa trước, nơi hệ thống sẽ monitor và phát hiện xâm nhập.

### Các Loại ROI

#### A. Polygon ROI
```json
{
  "type": "polygon",
  "points": [[x1, y1], [x2, y2], [x3, y3], ...]
}
```
**Ưu điểm:** Linh hoạt, phù hợp với hình dạng bất kỳ

#### B. Rectangle ROI
```json
{
  "type": "rectangle",
  "x": x_top_left,
  "y": y_top_left,
  "width": w,
  "height": h
}
```
**Ưu điểm:** Đơn giản, tính toán nhanh

---

## 3. Overlap Detection - Phát Hiện Chồng Lấn

### Phương Pháp 1: IoU (Intersection over Union)

```python
def calculate_iou(box1, box2):
    # box: (x, y, w, h)
    x1, y1, w1, h1 = box1
    x2, y2, w2, h2 = box2

    # Intersection
    x_left = max(x1, x2)
    y_top = max(y1, y2)
    x_right = min(x1 + w1, x2 + w2)
    y_bottom = min(y1 + h1, y2 + h2)

    if x_right < x_left or y_bottom < y_top:
        return 0.0

    intersection = (x_right - x_left) * (y_bottom - y_top)

    # Union
    box1_area = w1 * h1
    box2_area = w2 * h2
    union = box1_area + box2_area - intersection

    return intersection / union
```

### Phương Pháp 2: Overlap Percentage

```python
def calculate_overlap_percentage(object_contour, roi):
    # Tính % diện tích object nằm trong ROI
    object_area = cv2.contourArea(object_contour)

    # Tạo mask cho object
    mask_object = np.zeros(shape, dtype=np.uint8)
    cv2.drawContours(mask_object, [object_contour], -1, 255, -1)

    # Tạo mask cho ROI
    mask_roi = np.zeros(shape, dtype=np.uint8)
    if roi['type'] == 'polygon':
        cv2.fillPoly(mask_roi, [np.array(roi['points'])], 255)
    else:
        cv2.rectangle(mask_roi, (x, y), (x+w, y+h), 255, -1)

    # Intersection
    intersection = cv2.bitwise_and(mask_object, mask_roi)
    intersection_area = cv2.countNonZero(intersection)

    return intersection_area / object_area
```

---

## 4. Intrusion Validation Criteria

### A. Overlap Threshold

```python
overlap_threshold = 0.3  # 30% object phải trong ROI
if overlap >= overlap_threshold:
    # Có thể là intrusion
```

**Chọn giá trị:**
- **0.2-0.3**: Lenient (cảnh báo sớm)
- **0.4-0.5**: Balanced
- **0.6-0.8**: Strict (chắc chắn xâm nhập)

### B. Time Threshold

```python
time_threshold = 1.0  # giây
if time_in_roi >= time_threshold:
    # Xác nhận là intrusion
```

**Mục đích:** Tránh false positives do:
- Người đi qua nhanh
- Nhiễu tạm thời
- Shadows

### C. Size Filter

```python
min_object_area = 1000  # pixels
if object_area >= min_object_area:
    # Object đủ lớn để xét
```

**Mục đích:** Lọc:
- Nhiễu nhỏ
- Bóng đổ
- Artifacts

---

## 5. Temporal Consistency - Tracking Qua Thời Gian

### Intrusion Tracking Data Structure

```python
intrusion_tracking = {
    'object_id_1': {
        'first_seen': timestamp,
        'last_seen': timestamp,
        'roi_name': 'Cửa Chính',
        'duration': 2.3  # seconds
    }
}
```

### Algorithm

```python
def detect_intrusion(contour, roi, current_time):
    # 1. Tính overlap
    overlap = calculate_overlap(contour, roi)

    if overlap >= overlap_threshold:
        # 2. Tạo unique key cho tracking
        key = generate_tracking_key(contour, roi)

        # 3. Update tracking data
        if key not in intrusion_tracking:
            intrusion_tracking[key] = {
                'first_seen': current_time,
                'roi_name': roi['name']
            }
        else:
            intrusion_tracking[key]['last_seen'] = current_time

        # 4. Kiểm tra time threshold
        duration = current_time - intrusion_tracking[key]['first_seen']

        if duration >= time_threshold:
            return True  # Xác nhận intrusion

    return False
```

---

## 6. Point-in-Polygon Test

### Kiểm Tra Điểm Có Trong Polygon

```python
def point_in_polygon(point, polygon):
    """Ray casting algorithm"""
    x, y = point
    n = len(polygon)
    inside = False

    p1x, p1y = polygon[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        p1x, p1y = p2x, p2y

    return inside
```

### Sử Dụng OpenCV

```python
import cv2

result = cv2.pointPolygonTest(polygon_points, point, False)
# result >= 0: inside
# result < 0: outside
```

---

## 7. False Positive Reduction

### Các Nguyên Nhân False Positives

1. **Shadows** - Bóng đổ
2. **Lighting changes** - Thay đổi ánh sáng đột ngột
3. **Camera shake** - Rung camera
4. **Small noise** - Nhiễu nhỏ
5. **Reflections** - Phản chiếu

### Strategies Để Giảm

#### A. Shadow Detection
```python
# Bật trong MOG2
bg_subtractor = cv2.createBackgroundSubtractorMOG2(detectShadows=True)
fg_mask = bg_subtractor.apply(frame)

# Loại bỏ shadows (giá trị 127)
fg_mask[fg_mask == 127] = 0
```

#### B. Morphological Filtering
```python
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_OPEN, kernel)
fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_CLOSE, kernel)
```

#### C. Size Filtering
```python
# Chỉ giữ objects đủ lớn
if cv2.contourArea(contour) < min_area:
    continue
```

#### D. Time-based Validation
```python
# Phải persist một thời gian
if duration < time_threshold:
    continue  # Không cảnh báo
```

---

## 8. Multi-Object Tracking

### Challenges

- Nhiều người cùng lúc
- Occlusions (che khuất)
- ID switching

### Giải Pháp Đơn Giản: Centroid Tracking

```python
def track_objects(contours):
    tracked_objects = {}

    for contour in contours:
        # Tính centroid
        M = cv2.moments(contour)
        if M["m00"] != 0:
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])

            # Find closest existing object
            min_dist = float('inf')
            closest_id = None

            for obj_id, obj_data in tracked_objects.items():
                dist = np.sqrt((cx - obj_data['cx'])**2 + (cy - obj_data['cy'])**2)
                if dist < min_dist and dist < max_distance_threshold:
                    min_dist = dist
                    closest_id = obj_id

            if closest_id:
                # Update existing
                tracked_objects[closest_id] = {'cx': cx, 'cy': cy}
            else:
                # Create new
                new_id = generate_new_id()
                tracked_objects[new_id] = {'cx': cx, 'cy': cy}

    return tracked_objects
```

---

## 9. Alert Triggering Logic

### Complete Pipeline

```python
def intrusion_detection_pipeline(frame, rois, current_time):
    alerts = []

    # 1. Motion detection
    fg_mask = motion_detector.detect(frame)

    # 2. Find contours
    contours = find_contours(fg_mask)

    # 3. For each contour
    for contour in contours:
        area = cv2.contourArea(contour)

        # Size filter
        if area < min_object_area:
            continue

        # 4. Check against each ROI
        for roi in rois:
            overlap = calculate_overlap(contour, roi)

            # Overlap threshold
            if overlap < overlap_threshold:
                continue

            # 5. Temporal tracking
            key = generate_key(contour, roi)

            if key not in tracking:
                tracking[key] = {
                    'first_seen': current_time,
                    'roi_name': roi['name']
                }
            else:
                tracking[key]['last_seen'] = current_time

            # Time threshold
            duration = current_time - tracking[key]['first_seen']

            if duration >= time_threshold:
                # TRIGGER ALERT
                alerts.append({
                    'roi_name': roi['name'],
                    'duration': duration,
                    'bbox': cv2.boundingRect(contour),
                    'area': area
                })

    return alerts
```

---

## 10. Performance Metrics

### Confusion Matrix

|  | Predicted: Intrusion | Predicted: No Intrusion |
|---|---------------------|------------------------|
| **Actual: Intrusion** | True Positive (TP) | False Negative (FN) |
| **Actual: No Intrusion** | False Positive (FP) | True Negative (TN) |

### Metrics

```python
Precision = TP / (TP + FP)
Recall = TP / (TP + FN)
F1-Score = 2 * (Precision * Recall) / (Precision + Recall)
Accuracy = (TP + TN) / (TP + TN + FP + FN)
```

---

## 11. Tài Liệu Tham Khảo

- "Real-time intrusion detection for surveillance systems" (Zhang et al., 2015)
- "Video surveillance using computer vision" (Collins et al., 2000)
- OpenCV Documentation: Object Tracking

---

**Ngày tạo**: Tháng 1/2025
**Phiên bản**: 1.0
