# Intrusion Detection (Phát Hiện Xâm Nhập)

## 1. Tổng Quan

**Intrusion Detection** (Phát hiện xâm nhập) là kỹ thuật phát hiện khi đối tượng (người) xâm nhập vào khu vực cấm (ROI - Region of Interest/Vùng quan tâm).

---

## 2. Khái Niệm ROI (Region of Interest - Vùng Quan Tâm)

### Định Nghĩa

ROI là vùng được định nghĩa trước, nơi hệ thống sẽ giám sát (monitor) và phát hiện xâm nhập.

### Các Loại ROI

#### A. Polygon ROI (ROI đa giác)
```json
{
  "type": "polygon",
  "points": [[x1, y1], [x2, y2], [x3, y3], ...]
}
```
**Ưu điểm:** Linh hoạt, phù hợp với hình dạng bất kỳ

#### B. Rectangle ROI (ROI hình chữ nhật)
```json
{
  "type": "rectangle",
  "x": x_top_left,
  "y": y_top_left,
  "width": w,
  "height": h
}
```
**Ưu điểm:** Đơn giản, tính toán nhanh

---

## 3. Overlap Detection (Phát Hiện Chồng Lấn)

### Phương Pháp 1: IoU (Intersection over Union - Giao trên hợp)

```python
def calculate_iou(box1, box2):
    # box: (x, y, w, h)
    x1, y1, w1, h1 = box1
    x2, y2, w2, h2 = box2

    # Vùng giao (Intersection)
    x_left = max(x1, x2)
    y_top = max(y1, y2)
    x_right = min(x1 + w1, x2 + w2)
    y_bottom = min(y1 + h1, y2 + h2)

    if x_right < x_left or y_bottom < y_top:
        return 0.0

    intersection = (x_right - x_left) * (y_bottom - y_top)

    # Vùng hợp (Union)
    box1_area = w1 * h1
    box2_area = w2 * h2
    union = box1_area + box2_area - intersection

    return intersection / union
```

### Phương Pháp 2: Overlap Percentage (Tỷ lệ chồng lấn)

```python
def calculate_overlap_percentage(object_contour, roi):
    # Tính % diện tích vật thể nằm trong ROI
    object_area = cv2.contourArea(object_contour)

    # Tạo mask cho vật thể
    mask_object = np.zeros(shape, dtype=np.uint8)
    cv2.drawContours(mask_object, [object_contour], -1, 255, -1)

    # Tạo mask cho ROI
    mask_roi = np.zeros(shape, dtype=np.uint8)
    if roi['type'] == 'polygon':
        cv2.fillPoly(mask_roi, [np.array(roi['points'])], 255)
    else:
        cv2.rectangle(mask_roi, (x, y), (x+w, y+h), 255, -1)

    # Vùng giao
    intersection = cv2.bitwise_and(mask_object, mask_roi)
    intersection_area = cv2.countNonZero(intersection)

    return intersection_area / object_area
```

---

## 4. Tiêu Chí Xác Thực Xâm Nhập (Intrusion Validation Criteria)

### A. Overlap Threshold (Ngưỡng chồng lấn)

```python
overlap_threshold = 0.3  # 30% vật thể phải trong ROI
if overlap >= overlap_threshold:
    # Có thể là xâm nhập
```

**Chọn giá trị:**
- **0.2-0.3**: Dễ dãi (lenient) - cảnh báo sớm
- **0.4-0.5**: Cân bằng (balanced)
- **0.6-0.8**: Nghiêm ngặt (strict) - chắc chắn xâm nhập

### B. Time Threshold (Ngưỡng thời gian)

```python
time_threshold = 1.0  # giây
if time_in_roi >= time_threshold:
    # Xác nhận là xâm nhập
```

**Mục đích:** Tránh phát hiện sai (false positives) do:
- Người đi qua nhanh
- Nhiễu tạm thời
- Bóng đổ (shadows)

### C. Size Filter (Lọc kích thước)

```python
min_object_area = 1000  # pixels
if object_area >= min_object_area:
    # Vật thể đủ lớn để xét
```

**Mục đích:** Lọc:
- Nhiễu nhỏ
- Bóng đổ
- Nhiễu hình ảnh (artifacts)

---

## 5. Temporal Consistency (Tính Nhất Quán Theo Thời Gian) - Tracking Qua Thời Gian

### Cấu Trúc Dữ Liệu Tracking Xâm Nhập

```python
intrusion_tracking = {
    'object_id_1': {
        'first_seen': timestamp,
        'last_seen': timestamp,
        'roi_name': 'Cửa Chính',
        'duration': 2.3  # giây
    }
}
```

### Thuật Toán

```python
def detect_intrusion(contour, roi, current_time):
    # 1. Tính độ chồng lấn
    overlap = calculate_overlap(contour, roi)

    if overlap >= overlap_threshold:
        # 2. Tạo khóa duy nhất cho tracking
        key = generate_tracking_key(contour, roi)

        # 3. Cập nhật dữ liệu tracking
        if key not in intrusion_tracking:
            intrusion_tracking[key] = {
                'first_seen': current_time,
                'roi_name': roi['name']
            }
        else:
            intrusion_tracking[key]['last_seen'] = current_time

        # 4. Kiểm tra ngưỡng thời gian
        duration = current_time - intrusion_tracking[key]['first_seen']

        if duration >= time_threshold:
            return True  # Xác nhận xâm nhập

    return False
```

---

## 6. Point-in-Polygon Test (Kiểm Tra Điểm Trong Đa Giác)

### Kiểm Tra Điểm Có Trong Đa Giác

```python
def point_in_polygon(point, polygon):
    """Thuật toán Ray casting (Phóng tia)"""
    x, y = point
    n = len(polygon)
    inside = False

    p1x, p1y = polygon[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        p1x, p1y = p2x, p2y

    return inside
```

### Sử Dụng OpenCV

```python
import cv2

result = cv2.pointPolygonTest(polygon_points, point, False)
# result >= 0: bên trong
# result < 0: bên ngoài
```

---

## 7. Giảm Phát Hiện Sai (False Positive Reduction)

### Các Nguyên Nhân Phát Hiện Sai

1. **Shadows** (Bóng đổ)
2. **Lighting changes** (Thay đổi ánh sáng đột ngột)
3. **Camera shake** (Rung camera)
4. **Small noise** (Nhiễu nhỏ)
5. **Reflections** (Phản chiếu)

### Chiến Lược Giảm Thiểu

#### A. Shadow Detection (Phát hiện bóng đổ)
```python
# Bật trong MOG2
bg_subtractor = cv2.createBackgroundSubtractorMOG2(detectShadows=True)
fg_mask = bg_subtractor.apply(frame)

# Loại bỏ bóng đổ (giá trị 127)
fg_mask[fg_mask == 127] = 0
```

#### B. Morphological Filtering (Lọc hình thái)
```python
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_OPEN, kernel)
fg_mask = cv2.morphologyEx(fg_mask, cv2.MORPH_CLOSE, kernel)
```

#### C. Size Filtering (Lọc kích thước)
```python
# Chỉ giữ vật thể đủ lớn
if cv2.contourArea(contour) < min_area:
    continue
```

#### D. Time-based Validation (Xác thực dựa trên thời gian)
```python
# Phải tồn tại một thời gian
if duration < time_threshold:
    continue  # Không cảnh báo
```

---

## 8. Multi-Object Tracking (Theo Dõi Đa Đối Tượng)

### Thách Thức

- Nhiều người cùng lúc
- Occlusions (Che khuất)
- ID switching (Hoán đổi định danh)

### Giải Pháp Đơn Giản: Centroid Tracking (Theo dõi trọng tâm)

```python
def track_objects(contours):
    tracked_objects = {}

    for contour in contours:
        # Tính trọng tâm
        M = cv2.moments(contour)
        if M["m00"] != 0:
            cx = int(M["m10"] / M["m00"])
            cy = int(M["m01"] / M["m00"])

            # Tìm vật thể hiện có gần nhất
            min_dist = float('inf')
            closest_id = None

            for obj_id, obj_data in tracked_objects.items():
                dist = np.sqrt((cx - obj_data['cx'])**2 + (cy - obj_data['cy'])**2)
                if dist < min_dist and dist < max_distance_threshold:
                    min_dist = dist
                    closest_id = obj_id

            if closest_id:
                # Cập nhật vật thể hiện có
                tracked_objects[closest_id] = {'cx': cx, 'cy': cy}
            else:
                # Tạo mới
                new_id = generate_new_id()
                tracked_objects[new_id] = {'cx': cx, 'cy': cy}

    return tracked_objects
```

---

## 9. Logic Kích Hoạt Cảnh Báo (Alert Triggering Logic)

### Quy Trình Hoàn Chỉnh

```python
def intrusion_detection_pipeline(frame, rois, current_time):
    alerts = []

    # 1. Phát hiện chuyển động
    fg_mask = motion_detector.detect(frame)

    # 2. Tìm đường viền
    contours = find_contours(fg_mask)

    # 3. Với mỗi đường viền
    for contour in contours:
        area = cv2.contourArea(contour)

        # Lọc kích thước
        if area < min_object_area:
            continue

        # 4. Kiểm tra với từng ROI
        for roi in rois:
            overlap = calculate_overlap(contour, roi)

            # Ngưỡng chồng lấn
            if overlap < overlap_threshold:
                continue

            # 5. Theo dõi theo thời gian
            key = generate_key(contour, roi)

            if key not in tracking:
                tracking[key] = {
                    'first_seen': current_time,
                    'roi_name': roi['name']
                }
            else:
                tracking[key]['last_seen'] = current_time

            # Ngưỡng thời gian
            duration = current_time - tracking[key]['first_seen']

            if duration >= time_threshold:
                # KÍCH HOẠT CẢNH BÁO
                alerts.append({
                    'roi_name': roi['name'],
                    'duration': duration,
                    'bbox': cv2.boundingRect(contour),
                    'area': area
                })

    return alerts
```

---

## 10. Chỉ Số Hiệu Suất (Performance Metrics)

### Confusion Matrix (Ma Trận Nhầm Lẫn)

|  | Dự đoán: Xâm nhập | Dự đoán: Không xâm nhập |
|---|---------------------|------------------------|
| **Thực tế: Xâm nhập** | True Positive (TP) | False Negative (FN) |
| **Thực tế: Không xâm nhập** | False Positive (FP) | True Negative (TN) |

### Các Chỉ Số

```python
Precision (Độ chính xác) = TP / (TP + FP)
Recall (Độ phủ) = TP / (TP + FN)
F1-Score = 2 * (Precision * Recall) / (Precision + Recall)
Accuracy (Độ chính xác tổng thể) = (TP + TN) / (TP + TN + FP + FN)
```

---

## 11. Tài Liệu Tham Khảo

- "Real-time intrusion detection for surveillance systems" (Zhang et al., 2015)
- "Video surveillance using computer vision" (Collins et al., 2000)
- OpenCV Documentation: Object Tracking

---

**Ngày tạo**: Tháng 1/2025
**Phiên bản**: 1.0
