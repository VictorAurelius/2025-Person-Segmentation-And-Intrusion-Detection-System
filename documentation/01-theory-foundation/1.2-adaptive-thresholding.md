# Adaptive Thresholding (Ngưỡng Thích Ứng) - Xử Lý Ánh Sáng Thay Đổi

## 1. Khái Niệm

**Adaptive Thresholding** (Ngưỡng thích ứng) là kỹ thuật ngưỡng hóa động, tính ngưỡng riêng biệt cho từng vùng cục bộ (local) của ảnh thay vì dùng một giá trị toàn cục (global).

---

## 2. Tại Sao Cần Adaptive Thresholding?

### Vấn Đề Với Global Thresholding (Ngưỡng Toàn Cục)

```python
_, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
```

**Hạn chế:**
- Thất bại với ánh sáng không đồng đều
- Một ngưỡng không phù hợp cho toàn bộ ảnh
- Vùng sáng và tối cần ngưỡng khác nhau

### Giải Pháp Adaptive

Tính ngưỡng riêng cho từng pixel dựa trên vùng lân cận.

---

## 3. Các Phương Pháp

### A. Adaptive Mean Threshold (Ngưỡng trung bình thích ứng)

```python
binary = cv2.adaptiveThreshold(gray, 255,
    cv2.ADAPTIVE_THRESH_MEAN_C,
    cv2.THRESH_BINARY, block_size, C)
```

**Công thức:**
```
T(x, y) = mean(block) - C
```

### B. Adaptive Gaussian Threshold (Ngưỡng Gaussian thích ứng)

```python
binary = cv2.adaptiveThreshold(gray, 255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY, block_size, C)
```

**Công thức:**
```
T(x, y) = gaussian_weighted_mean(block) - C
```

**Ưu điểm:** Mượt hơn, tốt cho gradient (độ dốc cường độ sáng)

---

## 4. Tham Số Quan Trọng

### block_size (Kích thước khối)

- Kích thước vùng lân cận (phải là số lẻ)
- **Nhỏ (7-11)**: Thích ứng nhiều → có thể bị nhiễu
- **Trung bình (11-15)**: Cân bằng
- **Lớn (15-25)**: Mượt → ít nhiễu

### C - Constant (Hằng số)

- Giá trị trừ đi từ mean (trung bình)
- **C dương (2-5)**: Ngưỡng thấp → nhiều vùng tiền cảnh (foreground)
- **C âm hoặc 0**: Ngưỡng cao → ít vùng tiền cảnh
- **Điều chỉnh:** Thử từng giá trị để tìm tốt nhất

---

## 5. Otsu's Method (Phương Pháp Otsu) - Automatic Threshold (Ngưỡng Tự Động)

```python
_, binary = cv2.threshold(gray, 0, 255,
    cv2.THRESH_BINARY + cv2.THRESH_OTSU)
```

**Cách hoạt động:**
1. Tính histogram của ảnh
2. Thử tất cả giá trị ngưỡng có thể
3. Chọn ngưỡng tối thiểu hóa phương sai trong lớp (minimize intra-class variance)
4. Tối ưu cho histogram hai đỉnh (bimodal histograms)

**Khi nào dùng:**
- Histogram có 2 đỉnh rõ ràng (foreground/background)
- Ánh sáng tương đối đồng đều

---

## 6. So Sánh Các Phương Pháp

| Phương pháp | Tốt nhất cho | Ưu điểm | Nhược điểm |
|--------|--------------|---------|-----------|
| **Global** | Ánh sáng đồng đều | Đơn giản, nhanh | Thất bại với gradient |
| **Otsu** | Histogram hai đỉnh | Tự động | Không thích ứng |
| **Adaptive Mean** | Ánh sáng thay đổi | Xử lý gradient | Chậm hơn |
| **Adaptive Gaussian** | Gradient mượt | Chất lượng tốt nhất | Chậm nhất |

---

## 7. Chiến Lược Điều Chỉnh Tham Số

### Theo Điều Kiện Ánh Sáng

```yaml
# Ban ngày (độ tương phản cao)
threshold:
  method: "gaussian"
  block_size: 11
  C: 2

# Trong nhà (độ tương phản thấp)
threshold:
  method: "gaussian"
  block_size: 15
  C: 3

# Ban đêm (nhiễu cao)
threshold:
  method: "gaussian"
  block_size: 21
  C: 5
```

### Mẹo Chọn Tham Số

1. **Bắt đầu với:** block_size=11, C=2
2. **Nếu quá nhiễu:** Tăng block_size
3. **Nếu mất chi tiết:** Giảm block_size
4. **Nếu quá nhiều vùng tiền cảnh:** Tăng C
5. **Nếu quá ít vùng tiền cảnh:** Giảm C

---

## 8. Ví Dụ Triển Khai

### Adaptive Threshold Cơ Bản

```python
import cv2

# Đọc ảnh
img = cv2.imread('image.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Adaptive Mean
adaptive_mean = cv2.adaptiveThreshold(gray, 255,
    cv2.ADAPTIVE_THRESH_MEAN_C,
    cv2.THRESH_BINARY, 11, 2)

# Adaptive Gaussian
adaptive_gaussian = cv2.adaptiveThreshold(gray, 255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY, 11, 2)

# Otsu
_, otsu = cv2.threshold(gray, 0, 255,
    cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Hiển thị
cv2.imshow('Adaptive Mean', adaptive_mean)
cv2.imshow('Adaptive Gaussian', adaptive_gaussian)
cv2.imshow('Otsu', otsu)
cv2.waitKey(0)
```

### Với Tiền Xử Lý

```python
def adaptive_with_preprocessing(image):
    # Chuyển sang ảnh xám
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Cân bằng histogram
    gray = cv2.equalizeHist(gray)

    # Gaussian blur để giảm nhiễu
    gray = cv2.GaussianBlur(gray, (5, 5), 0)

    # Ngưỡng thích ứng
    binary = cv2.adaptiveThreshold(gray, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,  # Đảo ngược: người = trắng
        block_size=15,
        C=3)

    # Phép toán hình thái
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    binary = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    return binary
```

---

## 9. CLAHE - Contrast Limited Adaptive Histogram Equalization (Cân Bằng Histogram Thích Ứng Có Giới Hạn Tương Phản)

### Khái Niệm

CLAHE cải thiện độ tương phản (contrast) cục bộ, đặc biệt hữu ích cho ảnh thiếu sáng.

### Triển Khai

```python
# Tạo đối tượng CLAHE
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))

# Áp dụng cho ảnh xám
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
enhanced = clahe.apply(gray)

# Hoặc cho ảnh màu (trên kênh L)
lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
l, a, b = cv2.split(lab)
l = clahe.apply(l)
enhanced = cv2.merge([l, a, b])
enhanced = cv2.cvtColor(enhanced, cv2.COLOR_LAB2BGR)
```

---

## 10. Ứng Dụng Trong Intrusion Detection (Phát Hiện Xâm Nhập)

### Quy Trình Hoàn Chỉnh

```python
def process_for_intrusion(frame):
    # 1. Chuyển sang ảnh xám
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # 2. CLAHE nếu cần (ánh sáng yếu)
    # clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    # gray = clahe.apply(gray)

    # 3. Làm mờ để giảm nhiễu
    gray = cv2.GaussianBlur(gray, (5, 5), 0)

    # 4. Ngưỡng thích ứng
    binary = cv2.adaptiveThreshold(gray, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        11, 2)

    # 5. Phép toán hình thái để làm sạch
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    binary = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    return binary
```

---

## 11. Tài Liệu Tham Khảo

- Otsu's original paper (1979)
- "Adaptive Thresholding for the DigitalDesk" (Wellner, 1993)
- Digital Image Processing (Gonzalez & Woods) - Chapter 10

---

**Ngày tạo**: Tháng 1/2025
**Phiên bản**: 1.0
