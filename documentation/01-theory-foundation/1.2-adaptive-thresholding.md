# Adaptive Thresholding - Xử Lý Ánh Sáng Thay Đổi

## 1. Khái Niệm

**Adaptive Thresholding** là kỹ thuật threshold động, tính threshold riêng biệt cho từng vùng local của ảnh thay vì dùng một giá trị global.

---

## 2. Tại Sao Cần Adaptive Thresholding?

### Vấn Đề Global Thresholding

```python
_, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
```

**Hạn chế:**
- Thất bại với ánh sáng không đồng đều
- Một threshold không phù hợp cho toàn bộ ảnh
- Vùng sáng và tối cần threshold khác nhau

### Giải Pháp Adaptive

Tính threshold riêng cho từng pixel dựa trên vùng lân cận.

---

## 3. Các Phương Pháp

### A. Adaptive Mean Threshold

```python
binary = cv2.adaptiveThreshold(gray, 255,
    cv2.ADAPTIVE_THRESH_MEAN_C,
    cv2.THRESH_BINARY, block_size, C)
```

**Công thức:**
```
T(x, y) = mean(block) - C
```

### B. Adaptive Gaussian Threshold

```python
binary = cv2.adaptiveThreshold(gray, 255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY, block_size, C)
```

**Công thức:**
```
T(x, y) = gaussian_weighted_mean(block) - C
```

**Ưu điểm:** Mượt hơn, tốt cho gradients

---

## 4. Tham Số Quan Trọng

### block_size

- Kích thước vùng lân cận (phải là số lẻ)
- **Nhỏ (7-11)**: Adaptive nhiều → có thể nhiễu
- **Trung bình (11-15)**: Cân bằng
- **Lớn (15-25)**: Mượt → ít nhiễu

### C - Constant

- Giá trị trừ đi từ mean
- **C dương (2-5)**: Threshold thấp → nhiều foreground
- **C âm hoặc 0**: Threshold cao → ít foreground
- **Điều chỉnh:** Thử từng giá trị để tìm tốt nhất

---

## 5. Otsu's Method - Automatic Threshold

```python
_, binary = cv2.threshold(gray, 0, 255,
    cv2.THRESH_BINARY + cv2.THRESH_OTSU)
```

**Cách hoạt động:**
1. Tính histogram của ảnh
2. Thử tất cả giá trị threshold có thể
3. Chọn threshold minimize intra-class variance
4. Tối ưu cho bimodal histograms

**Khi nào dùng:**
- Histogram có 2 peaks rõ ràng (foreground/background)
- Ánh sáng tương đối đồng đều

---

## 6. So Sánh Các Phương Pháp

| Method | Tốt nhất cho | Ưu điểm | Nhược điểm |
|--------|--------------|---------|-----------|
| **Global** | Ánh sáng đồng đều | Đơn giản, nhanh | Thất bại với gradients |
| **Otsu** | Bimodal histogram | Tự động | Không adaptive |
| **Adaptive Mean** | Ánh sáng thay đổi | Xử lý gradients | Chậm hơn |
| **Adaptive Gaussian** | Gradients mượt | Chất lượng tốt nhất | Chậm nhất |

---

## 7. Parameter Tuning Strategies

### Theo Điều Kiện Ánh Sáng

```yaml
# Ban ngày (độ tương phản cao)
threshold:
  method: "gaussian"
  block_size: 11
  C: 2

# Trong nhà (độ tương phản thấp)
threshold:
  method: "gaussian"
  block_size: 15
  C: 3

# Ban đêm (nhiễu cao)
threshold:
  method: "gaussian"
  block_size: 21
  C: 5
```

### Tips Chọn Tham Số

1. **Bắt đầu với:** block_size=11, C=2
2. **Nếu quá nhiễu:** Tăng block_size
3. **Nếu mất chi tiết:** Giảm block_size
4. **Nếu quá nhiều foreground:** Tăng C
5. **Nếu quá ít foreground:** Giảm C

---

## 8. Implementation Example

### Basic Adaptive Threshold

```python
import cv2

# Đọc ảnh
img = cv2.imread('image.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Adaptive Mean
adaptive_mean = cv2.adaptiveThreshold(gray, 255,
    cv2.ADAPTIVE_THRESH_MEAN_C,
    cv2.THRESH_BINARY, 11, 2)

# Adaptive Gaussian
adaptive_gaussian = cv2.adaptiveThreshold(gray, 255,
    cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv2.THRESH_BINARY, 11, 2)

# Otsu
_, otsu = cv2.threshold(gray, 0, 255,
    cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Hiển thị
cv2.imshow('Adaptive Mean', adaptive_mean)
cv2.imshow('Adaptive Gaussian', adaptive_gaussian)
cv2.imshow('Otsu', otsu)
cv2.waitKey(0)
```

### Với Preprocessing

```python
def adaptive_with_preprocessing(image):
    # Chuyển sang grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Histogram equalization
    gray = cv2.equalizeHist(gray)

    # Gaussian blur để giảm nhiễu
    gray = cv2.GaussianBlur(gray, (5, 5), 0)

    # Adaptive threshold
    binary = cv2.adaptiveThreshold(gray, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,  # Inverse: người = trắng
        block_size=15,
        C=3)

    # Morphological operations
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    binary = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    return binary
```

---

## 9. CLAHE - Contrast Limited Adaptive Histogram Equalization

### Khái Niệm

CLAHE cải thiện contrast cục bộ, đặc biệt hữu ích cho ảnh thiếu sáng.

### Implementation

```python
# Tạo CLAHE object
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))

# Áp dụng cho grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
enhanced = clahe.apply(gray)

# Hoặc cho color image (trên L channel)
lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
l, a, b = cv2.split(lab)
l = clahe.apply(l)
enhanced = cv2.merge([l, a, b])
enhanced = cv2.cvtColor(enhanced, cv2.COLOR_LAB2BGR)
```

---

## 10. Ứng Dụng Trong Intrusion Detection

### Pipeline Hoàn Chỉnh

```python
def process_for_intrusion(frame):
    # 1. Chuyển grayscale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # 2. CLAHE nếu cần (low-light)
    # clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    # gray = clahe.apply(gray)

    # 3. Blur để giảm nhiễu
    gray = cv2.GaussianBlur(gray, (5, 5), 0)

    # 4. Adaptive threshold
    binary = cv2.adaptiveThreshold(gray, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        11, 2)

    # 5. Morphology để clean up
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    binary = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel)
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    return binary
```

---

## 11. Tài Liệu Tham Khảo

- Otsu's original paper (1979)
- "Adaptive Thresholding for the DigitalDesk" (Wellner, 1993)
- Digital Image Processing (Gonzalez & Woods) - Chapter 10

---

**Ngày tạo**: Tháng 1/2025
**Phiên bản**: 1.0
