# Chi Tiết Triển Khai

## 1. Code Structure

```
src/
├── main.py                 # Entry point
├── motion_detector.py      # Motion detection
├── adaptive_threshold.py   # Thresholding
├── edge_detector.py        # Edge detection
├── region_grower.py        # Region growing
├── intrusion_detector.py   # Intrusion logic
├── alert_system.py         # Alerts
└── utils.py                # Helper functions
```

---

## 2. Key Classes

### MotionDetector Class

```python
class MotionDetector:
    def __init__(self, method, threshold):
        self.method = method
        self.bg_subtractor = self._create_subtractor()

    def detect(self, frame):
        fg_mask = self.bg_subtractor.apply(frame)
        return self._post_process(fg_mask)

    def get_contours(self, mask, min_area):
        contours, _ = cv2.findContours(mask, ...)
        return [c for c in contours if cv2.contourArea(c) >= min_area]
```

### IntrusionDetector Class

```python
class IntrusionDetector:
    def __init__(self, rois, overlap_threshold, time_threshold):
        self.rois = rois
        self.tracking = defaultdict(dict)

    def detect_intrusions(self, contours, current_time):
        flags = []
        details = []

        for contour in contours:
            for roi in self.rois:
                overlap = self._calculate_overlap(contour, roi)
                if overlap >= self.overlap_threshold:
                    # Tracking logic...
                    if duration >= self.time_threshold:
                        flags.append(True)
                        details.append({...})

        return flags, details
```

---

## 3. Design Patterns

### A. Factory Pattern

```python
def create_motion_detector(config):
    if config.motion.method == "MOG2":
        return MOG2Detector(config)
    elif config.motion.method == "KNN":
        return KNNDetector(config)
    else:
        return FrameDiffDetector(config)
```

### B. Strategy Pattern

```python
class ThresholdStrategy:
    def apply(self, image): pass

class GaussianThreshold(ThresholdStrategy):
    def apply(self, image):
        return cv2.adaptiveThreshold(...)

class OtsuThreshold(ThresholdStrategy):
    def apply(self, image):
        return cv2.threshold(..., cv2.THRESH_OTSU)
```

---

## 4. Error Handling

```python
try:
    frame = process_frame(frame)
except cv2.error as e:
    logging.error(f"OpenCV error: {e}")
    continue
except Exception as e:
    logging.error(f"Unexpected error: {e}")
    break
```

---

## 5. Performance Optimizations

### A. Numpy Vectorization

```python
# Slow
for i in range(height):
    for j in range(width):
        result[i,j] = image[i,j] * 2

# Fast
result = image * 2
```

### B. Caching

```python
@lru_cache(maxsize=128)
def expensive_computation(param):
    # Cached results
    return result
```

---

**Ngày tạo**: Tháng 1/2025
